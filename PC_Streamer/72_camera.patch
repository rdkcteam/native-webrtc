diff --git a/api/peerconnectioninterface.cc b/api/peerconnectioninterface.cc
index f2953b5..5b68f47 100644
--- a/api/peerconnectioninterface.cc
+++ b/api/peerconnectioninterface.cc
@@ -43,6 +43,7 @@ RTCErrorOr<rtc::scoped_refptr<RtpSenderInterface>>
 PeerConnectionInterface::AddTrack(
     rtc::scoped_refptr<MediaStreamTrackInterface> track,
     const std::vector<std::string>& stream_ids) {
+  printf("Inside AddTrack() \n");
   return RTCError(RTCErrorType::UNSUPPORTED_OPERATION, "Not implemented");
 }
 
@@ -233,6 +234,7 @@ rtc::scoped_refptr<VideoTrackSourceInterface>
 PeerConnectionFactoryInterface::CreateVideoSource(
     std::unique_ptr<cricket::VideoCapturer> capturer,
     const MediaConstraintsInterface* constraints) {
+  printf("Inside CreateVideoSource \n");
   return nullptr;
 }
 
diff --git a/examples/BUILD.gn b/examples/BUILD.gn
index 4ed07af..679cee0 100644
--- a/examples/BUILD.gn
+++ b/examples/BUILD.gn
@@ -703,16 +703,8 @@ if (is_linux || is_win) {
     if (is_linux) {
       sources += [
         "peerconnection/client/linux/main.cc",
-        "peerconnection/client/linux/main_wnd.cc",
-        "peerconnection/client/linux/main_wnd.h",
       ]
       cflags = [ "-Wno-deprecated-declarations" ]
-      libs = [
-        "X11",
-        "Xcomposite",
-        "Xext",
-        "Xrender",
-      ]
       deps += [ "//build/config/linux/gtk" ]
     }
 
diff --git a/examples/peerconnection/client/conductor.cc b/examples/peerconnection/client/conductor.cc
index a781c4a..4b9204c 100644
--- a/examples/peerconnection/client/conductor.cc
+++ b/examples/peerconnection/client/conductor.cc
@@ -13,6 +13,8 @@
 #include <memory>
 #include <utility>
 #include <vector>
+#include <glib.h>
+#include <string>
 
 #include "api/audio_codecs/builtin_audio_decoder_factory.h"
 #include "api/audio_codecs/builtin_audio_encoder_factory.h"
@@ -50,10 +52,27 @@ class DummySetSessionDescriptionObserver
   }
 };
 
-Conductor::Conductor(PeerConnectionClient* client, MainWindow* main_wnd)
-    : peer_id_(-1), loopback_(false), client_(client), main_wnd_(main_wnd) {
+struct UIThreadCallbackData {
+  explicit UIThreadCallbackData(Conductor* cb, int id, void* d)
+      : callback(cb), msg_id(id), data(d) {}
+  Conductor* callback;
+  int msg_id;
+  void* data;
+};
+
+gboolean HandleUIThreadCallback(gpointer data) {
+  printf("CALLBACK FROM MAINLOOP>>>>>>>>>>>>>>>>>>>>>>>>\n");
+  UIThreadCallbackData* cb_data = reinterpret_cast<UIThreadCallbackData*>(data);
+  cb_data->callback->UIThreadCallback(cb_data->msg_id, cb_data->data);
+  delete cb_data;
+  return false;
+}
+
+
+Conductor::Conductor(PeerConnectionClient* client)
+    : peer_id_(-1), loopback_(false), client_(client) {
   client_->RegisterObserver(this);
-  main_wnd->RegisterObserver(this);
+//  main_wnd->RegisterObserver(this);
 }
 
 Conductor::~Conductor() {
@@ -61,18 +80,28 @@ Conductor::~Conductor() {
 }
 
 bool Conductor::connection_active() const {
+   printf("connection_active");
+
   return peer_connection_ != nullptr;
 }
 
 void Conductor::Close() {
+printf("Conductor::Close()");
+
   client_->SignOut();
   DeletePeerConnection();
 }
 
+void Conductor::QueueUIThreadCallback(int msg_id, void* data) {
+  printf("Inside Conductor::QueueUIThreadCallback() : id: %d\n", msg_id);
+  g_idle_add(HandleUIThreadCallback,
+          new UIThreadCallbackData(this, msg_id, data));
+}
+
 bool Conductor::InitializePeerConnection() {
   RTC_DCHECK(!peer_connection_factory_);
   RTC_DCHECK(!peer_connection_);
-
+  printf("\nInitializePeerConnection\n"); 
   peer_connection_factory_ = webrtc::CreatePeerConnectionFactory(
       nullptr /* network_thread */, nullptr /* worker_thread */,
       nullptr /* signaling_thread */, nullptr /* default_adm */,
@@ -83,14 +112,16 @@ bool Conductor::InitializePeerConnection() {
       nullptr /* audio_processing */);
 
   if (!peer_connection_factory_) {
-    main_wnd_->MessageBox("Error", "Failed to initialize PeerConnectionFactory",
-                          true);
+  /*  main_wnd_->MessageBox("Error", "Failed to initialize PeerConnectionFactory",
+                          true);*/
+ printf("CreatePearConnectionFactory Failed\n");
     DeletePeerConnection();
     return false;
   }
 
   if (!CreatePeerConnection(/*dtls=*/true)) {
-    main_wnd_->MessageBox("Error", "CreatePeerConnection failed", true);
+//    main_wnd_->MessageBox("Error", "CreatePeerConnection failed", true);
+ printf("CreatePeerConnection Failed\n");
     DeletePeerConnection();
   }
 
@@ -100,16 +131,23 @@ bool Conductor::InitializePeerConnection() {
 }
 
 bool Conductor::ReinitializePeerConnectionForLoopback() {
+
+  printf("In Conductor::ReinitializePeerConnectionForLoopback()...\n");
   loopback_ = true;
   std::vector<rtc::scoped_refptr<webrtc::RtpSenderInterface>> senders =
       peer_connection_->GetSenders();
   peer_connection_ = nullptr;
   if (CreatePeerConnection(/*dtls=*/false)) {
     for (const auto& sender : senders) {
+      printf("Adding Track In Reinitialize!!!!!!!!!!!!!!!!\n"); 
       peer_connection_->AddTrack(sender->track(), sender->stream_ids());
     }
+     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions config;
+     config.offer_to_receive_video = 0;
+     config.offer_to_receive_audio = 0;
+
     peer_connection_->CreateOffer(
-        this, webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());
+        this,/* webrtc::PeerConnectionInterface::RTCOfferAnswerOptions()*/config);
   }
   return peer_connection_ != nullptr;
 }
@@ -131,8 +169,8 @@ bool Conductor::CreatePeerConnection(bool dtls) {
 }
 
 void Conductor::DeletePeerConnection() {
-  main_wnd_->StopLocalRenderer();
-  main_wnd_->StopRemoteRenderer();
+//  main_wnd_->StopLocalRenderer();
+ // main_wnd_->StopRemoteRenderer();
   peer_connection_ = nullptr;
   peer_connection_factory_ = nullptr;
   peer_id_ = -1;
@@ -141,10 +179,10 @@ void Conductor::DeletePeerConnection() {
 
 void Conductor::EnsureStreamingUI() {
   RTC_DCHECK(peer_connection_);
-  if (main_wnd_->IsWindow()) {
+ /* if (main_wnd_->IsWindow()) {
     if (main_wnd_->current_ui() != MainWindow::STREAMING)
       main_wnd_->SwitchToStreamingUI();
-  }
+  }*/
 }
 
 //
@@ -156,21 +194,23 @@ void Conductor::OnAddTrack(
     const std::vector<rtc::scoped_refptr<webrtc::MediaStreamInterface>>&
         streams) {
   RTC_LOG(INFO) << __FUNCTION__ << " " << receiver->id();
-  main_wnd_->QueueUIThreadCallback(NEW_TRACK_ADDED,
+  QueueUIThreadCallback(NEW_TRACK_ADDED,
                                    receiver->track().release());
 }
 
 void Conductor::OnRemoveTrack(
     rtc::scoped_refptr<webrtc::RtpReceiverInterface> receiver) {
   RTC_LOG(INFO) << __FUNCTION__ << " " << receiver->id();
-  main_wnd_->QueueUIThreadCallback(TRACK_REMOVED, receiver->track().release());
+  QueueUIThreadCallback(TRACK_REMOVED, receiver->track().release());
 }
 
 void Conductor::OnIceCandidate(const webrtc::IceCandidateInterface* candidate) {
+  printf("INSIDE Conductor::OnIceCandidate()...................\n");
   RTC_LOG(INFO) << __FUNCTION__ << " " << candidate->sdp_mline_index();
   // For loopback test. To save some connecting delay.
   if (loopback_) {
     if (!peer_connection_->AddIceCandidate(candidate)) {
+      printf("Failed to apply the received candidate \n");
       RTC_LOG(WARNING) << "Failed to apply the received candidate";
     }
     return;
@@ -183,6 +223,7 @@ void Conductor::OnIceCandidate(const webrtc::IceCandidateInterface* candidate) {
   jmessage[kCandidateSdpMlineIndexName] = candidate->sdp_mline_index();
   std::string sdp;
   if (!candidate->ToString(&sdp)) {
+    printf("Failed to serialize candidate \n");
     RTC_LOG(LS_ERROR) << "Failed to serialize candidate";
     return;
   }
@@ -196,7 +237,7 @@ void Conductor::OnIceCandidate(const webrtc::IceCandidateInterface* candidate) {
 
 void Conductor::OnSignedIn() {
   RTC_LOG(INFO) << __FUNCTION__;
-  main_wnd_->SwitchToPeerList(client_->peers());
+//  main_wnd_->SwitchToPeerList(client_->peers());
 }
 
 void Conductor::OnDisconnected() {
@@ -204,30 +245,33 @@ void Conductor::OnDisconnected() {
 
   DeletePeerConnection();
 
-  if (main_wnd_->IsWindow())
-    main_wnd_->SwitchToConnectUI();
+ /* if (main_wnd_->IsWindow())
+    main_wnd_->SwitchToConnectUI();*/
 }
 
 void Conductor::OnPeerConnected(int id, const std::string& name) {
   RTC_LOG(INFO) << __FUNCTION__;
+
+  printf("New Peer Connected: %d : %s\n", id, name.c_str());
   // Refresh the list if we're showing it.
-  if (main_wnd_->current_ui() == MainWindow::LIST_PEERS)
-    main_wnd_->SwitchToPeerList(client_->peers());
+  /*if (main_wnd_->current_ui() == MainWindow::LIST_PEERS)
+    main_wnd_->SwitchToPeerList(client_->peers());*/
 }
 
 void Conductor::OnPeerDisconnected(int id) {
   RTC_LOG(INFO) << __FUNCTION__;
   if (id == peer_id_) {
     RTC_LOG(INFO) << "Our peer disconnected";
-    main_wnd_->QueueUIThreadCallback(PEER_CONNECTION_CLOSED, NULL);
+    QueueUIThreadCallback(PEER_CONNECTION_CLOSED, NULL);
   } else {
     // Refresh the list if we're showing it.
-    if (main_wnd_->current_ui() == MainWindow::LIST_PEERS)
-      main_wnd_->SwitchToPeerList(client_->peers());
+   // if (main_wnd_->current_ui() == MainWindow::LIST_PEERS)
+     // main_wnd_->SwitchToPeerList(client_->peers());
   }
 }
 
 void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
+  printf("### OnMessageFromPeer \n");
   RTC_DCHECK(peer_id_ == peer_id || peer_id_ == -1);
   RTC_DCHECK(!message.empty());
 
@@ -236,12 +280,14 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
     peer_id_ = peer_id;
 
     if (!InitializePeerConnection()) {
+     printf("Failed to initialize our PeerConnection instance \n");
       RTC_LOG(LS_ERROR) << "Failed to initialize our PeerConnection instance";
       client_->SignOut();
       return;
     }
   } else if (peer_id != peer_id_) {
     RTC_DCHECK(peer_id_ != -1);
+    printf("Received a message from unknown peer while already in a conversation with a different peer.\n");
     RTC_LOG(WARNING)
         << "Received a message from unknown peer while already in a "
            "conversation with a different peer.";
@@ -251,7 +297,8 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
   Json::Reader reader;
   Json::Value jmessage;
   if (!reader.parse(message, jmessage)) {
-    RTC_LOG(WARNING) << "Received unknown message. " << message;
+    printf("Received unknown message \n");
+    RTC_LOG(INFO) << "Received unknown message. " << message;
     return;
   }
   std::string type_str;
@@ -264,6 +311,7 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
       // This is a loopback call.
       // Recreate the peerconnection with DTLS disabled.
       if (!ReinitializePeerConnectionForLoopback()) {
+        printf("Failed to initialize our PeerConnection instance \n");
         RTC_LOG(LS_ERROR) << "Failed to initialize our PeerConnection instance";
         DeletePeerConnection();
         client_->SignOut();
@@ -273,6 +321,7 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
     absl::optional<webrtc::SdpType> type_maybe =
         webrtc::SdpTypeFromString(type_str);
     if (!type_maybe) {
+      printf("Unknown SDP Type \n");
       RTC_LOG(LS_ERROR) << "Unknown SDP type: " << type_str;
       return;
     }
@@ -280,6 +329,7 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
     std::string sdp;
     if (!rtc::GetStringFromJsonObject(jmessage, kSessionDescriptionSdpName,
                                       &sdp)) {
+     printf("Can't parse received session description message. \n");
       RTC_LOG(WARNING) << "Can't parse received session description message.";
       return;
     }
@@ -287,17 +337,24 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
     std::unique_ptr<webrtc::SessionDescriptionInterface> session_description =
         webrtc::CreateSessionDescription(type, sdp, &error);
     if (!session_description) {
+      printf("Can't parse received session description message. \n");
       RTC_LOG(WARNING) << "Can't parse received session description message. "
                        << "SdpParseError was: " << error.description;
       return;
     }
+    printf(" Received session description \n");
+    printf("SDP is %s \n",message.c_str());
     RTC_LOG(INFO) << " Received session description :" << message;
     peer_connection_->SetRemoteDescription(
         DummySetSessionDescriptionObserver::Create(),
         session_description.release());
     if (type == webrtc::SdpType::kOffer) {
+      printf("OFFER RECEIVED FROM PEER : %d\n", peer_id);
+       webrtc::PeerConnectionInterface::RTCOfferAnswerOptions config;
+      config.offer_to_receive_video = 0;        
+      config.offer_to_receive_audio = 0;
       peer_connection_->CreateAnswer(
-          this, webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());
+          this, /* webrtc::PeerConnectionInterface::RTCOfferAnswerOptions()*/ config);
     }
   } else {
     std::string sdp_mid;
@@ -308,6 +365,7 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
         !rtc::GetIntFromJsonObject(jmessage, kCandidateSdpMlineIndexName,
                                    &sdp_mlineindex) ||
         !rtc::GetStringFromJsonObject(jmessage, kCandidateSdpName, &sdp)) {
+     printf( " #####  Can't parse received message. \n");
       RTC_LOG(WARNING) << "Can't parse received message.";
       return;
     }
@@ -315,26 +373,33 @@ void Conductor::OnMessageFromPeer(int peer_id, const std::string& message) {
     std::unique_ptr<webrtc::IceCandidateInterface> candidate(
         webrtc::CreateIceCandidate(sdp_mid, sdp_mlineindex, sdp, &error));
     if (!candidate.get()) {
+     printf( " #####  Can't parse received candidate message. \n");
       RTC_LOG(WARNING) << "Can't parse received candidate message. "
                        << "SdpParseError was: " << error.description;
       return;
     }
+      printf("Adding ICE Candidate.......\n\n\n\n\n\n\n");
     if (!peer_connection_->AddIceCandidate(candidate.get())) {
+     printf( " #####  Failed to apply the received candidate \n");
       RTC_LOG(WARNING) << "Failed to apply the received candidate";
       return;
     }
+    printf("Received candidate \n");
+    printf("candidate is %s \n",message.c_str());
     RTC_LOG(INFO) << " Received candidate :" << message;
   }
 }
 
 void Conductor::OnMessageSent(int err) {
   // Process the next pending message if any.
-  main_wnd_->QueueUIThreadCallback(SEND_MESSAGE_TO_PEER, NULL);
+ printf("/nConductor::OnMessageSent/n"); 
+  QueueUIThreadCallback(SEND_MESSAGE_TO_PEER, NULL);
 }
 
 void Conductor::OnServerConnectionFailure() {
-  main_wnd_->MessageBox("Error", ("Failed to connect to " + server_).c_str(),
-                        true);
+printf("Failed to connect server\n"); 
+/* main_wnd_->MessageBox("Error", ("Failed to connect to " + server_).c_str(),
+                        true);*/
 }
 
 //
@@ -345,10 +410,12 @@ void Conductor::StartLogin(const std::string& server, int port) {
   if (client_->is_connected())
     return;
   server_ = server;
+   printf("Peer name :%s\n", GetPeerName().c_str());
   client_->Connect(server, port, GetPeerName());
 }
 
 void Conductor::DisconnectFromServer() {
+   printf("\nDisconnectFromServer\n"); 
   if (client_->is_connected())
     client_->SignOut();
 }
@@ -358,17 +425,25 @@ void Conductor::ConnectToPeer(int peer_id) {
   RTC_DCHECK(peer_id != -1);
 
   if (peer_connection_.get()) {
-    main_wnd_->MessageBox(
-        "Error", "We only support connecting to one peer at a time", true);
+/*    main_wnd_->MessageBox(
+        "Error", "We only support connecting to one peer at a time", true);*/
+      printf("We only support connecting to one peer at a time\n");
     return;
   }
 
   if (InitializePeerConnection()) {
     peer_id_ = peer_id;
+
+   webrtc::PeerConnectionInterface::RTCOfferAnswerOptions config;        
+   config.offer_to_receive_video = 0;    
+   config.offer_to_receive_audio = 0;
+
     peer_connection_->CreateOffer(
-        this, webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());
+        this,/* webrtc::PeerConnectionInterface::RTCOfferAnswerOptions()*/config);
   } else {
-    main_wnd_->MessageBox("Error", "Failed to initialize PeerConnection", true);
+   // main_wnd_->MessageBox("Error", "Failed to initialize PeerConnection", true);
+    printf("Failed to initialize peerconnection");
+
   }
 }
 
@@ -378,6 +453,7 @@ std::unique_ptr<cricket::VideoCapturer> Conductor::OpenVideoCaptureDevice() {
     std::unique_ptr<webrtc::VideoCaptureModule::DeviceInfo> info(
         webrtc::VideoCaptureFactory::CreateDeviceInfo());
     if (!info) {
+      printf("info is null \n");
       return nullptr;
     }
     int num_devices = info->NumberOfDevices();
@@ -386,16 +462,19 @@ std::unique_ptr<cricket::VideoCapturer> Conductor::OpenVideoCaptureDevice() {
       char name[kSize] = {0};
       char id[kSize] = {0};
       if (info->GetDeviceName(i, name, kSize, id, kSize) != -1) {
+        printf("name is %s \n",name);
+        printf("Pushing device name \n");
         device_names.push_back(name);
       }
     }
   }
-
   cricket::WebRtcVideoDeviceCapturerFactory factory;
   std::unique_ptr<cricket::VideoCapturer> capturer;
   for (const auto& name : device_names) {
+    printf("Inside for (const auto& name : device_names) \n");
     capturer = factory.Create(cricket::Device(name, 0));
     if (capturer) {
+      printf("capturer found \n");
       break;
     }
   }
@@ -407,7 +486,8 @@ void Conductor::AddTracks() {
     return;  // Already added tracks.
   }
 
-  rtc::scoped_refptr<webrtc::AudioTrackInterface> audio_track(
+  printf("In Add Tracks.....!!!!!\n");
+  /* rtc::scoped_refptr<webrtc::AudioTrackInterface> audio_track(
       peer_connection_factory_->CreateAudioTrack(
           kAudioLabel, peer_connection_factory_->CreateAudioSource(
                            cricket::AudioOptions())));
@@ -415,27 +495,33 @@ void Conductor::AddTracks() {
   if (!result_or_error.ok()) {
     RTC_LOG(LS_ERROR) << "Failed to add audio track to PeerConnection: "
                       << result_or_error.error().message();
-  }
+  } */
 
   std::unique_ptr<cricket::VideoCapturer> video_device =
       OpenVideoCaptureDevice();
   if (video_device) {
+    printf("Inside if(video_device) \n");
     rtc::scoped_refptr<webrtc::VideoTrackInterface> video_track_(
         peer_connection_factory_->CreateVideoTrack(
             kVideoLabel, peer_connection_factory_->CreateVideoSource(
                              std::move(video_device), nullptr)));
-    main_wnd_->StartLocalRenderer(video_track_);
+  //  main_wnd_->StartLocalRenderer(video_track_);
 
-    result_or_error = peer_connection_->AddTrack(video_track_, {kStreamId});
+    printf("Adding Video Track!!!!!!!!!!!!!!!!!!\n"); 
+    auto result_or_error = peer_connection_->AddTrack(video_track_, {kStreamId});
     if (!result_or_error.ok()) {
+     printf("Failed to add video track to PeerConnection \n");
       RTC_LOG(LS_ERROR) << "Failed to add video track to PeerConnection: "
                         << result_or_error.error().message();
-    }
+    }else{
+     printf("Added video track to PeerConnection \n");
+   }
   } else {
+    printf("OpenVideoCaptureDevice failed \n");
     RTC_LOG(LS_ERROR) << "OpenVideoCaptureDevice failed";
   }
-
-  main_wnd_->SwitchToStreamingUI();
+  printf("Out AddTrack!!!!!!!!!!!!!!!!!!!\n");
+//  main_wnd_->SwitchToStreamingUI();
 }
 
 void Conductor::DisconnectFromCurrentPeer() {
@@ -445,17 +531,19 @@ void Conductor::DisconnectFromCurrentPeer() {
     DeletePeerConnection();
   }
 
-  if (main_wnd_->IsWindow())
-    main_wnd_->SwitchToPeerList(client_->peers());
+//  if (main_wnd_->IsWindow())
+//    main_wnd_->SwitchToPeerList(client_->peers());
 }
 
 void Conductor::UIThreadCallback(int msg_id, void* data) {
+  printf("In  Conductor::UIThreadCallback() :\n");
   switch (msg_id) {
     case PEER_CONNECTION_CLOSED:
+      printf("id: PEER_CONNECTION_CLOSED : %d\n" ,msg_id);
       RTC_LOG(INFO) << "PEER_CONNECTION_CLOSED";
       DeletePeerConnection();
 
-      if (main_wnd_->IsWindow()) {
+  /*    if (main_wnd_->IsWindow()) {
         if (client_->is_connected()) {
           main_wnd_->SwitchToPeerList(client_->peers());
         } else {
@@ -463,12 +551,16 @@ void Conductor::UIThreadCallback(int msg_id, void* data) {
         }
       } else {
         DisconnectFromServer();
-      }
+      }*/
       break;
 
     case SEND_MESSAGE_TO_PEER: {
+       printf("\npeer_id_:%d",peer_id_);
+       printf("id: SEND_MESSAGE_TO_PEER : %d\n" ,msg_id);
+
       RTC_LOG(INFO) << "SEND_MESSAGE_TO_PEER";
       std::string* msg = reinterpret_cast<std::string*>(data);
+       printf("MESSAGE%s",data);
       if (msg) {
         // For convenience, we always run the message through the queue.
         // This way we can be sure that messages are sent to the server
@@ -494,29 +586,35 @@ void Conductor::UIThreadCallback(int msg_id, void* data) {
     }
 
     case NEW_TRACK_ADDED: {
+         printf("id: NEW_TRACK_ADDED : %d\n" ,msg_id);
+/*
       auto* track = reinterpret_cast<webrtc::MediaStreamTrackInterface*>(data);
       if (track->kind() == webrtc::MediaStreamTrackInterface::kVideoKind) {
         auto* video_track = static_cast<webrtc::VideoTrackInterface*>(track);
-        main_wnd_->StartRemoteRenderer(video_track);
+        main_wnd_->StartRemoteRenderer(video_track); 
       }
-      track->Release();
+      track->Release();*/
       break;
     }
 
     case TRACK_REMOVED: {
+        printf("id: TRACK_REMOVED : %d\n" ,msg_id);
       // Remote peer stopped sending a track.
-      auto* track = reinterpret_cast<webrtc::MediaStreamTrackInterface*>(data);
-      track->Release();
+     /* auto* track = reinterpret_cast<webrtc::MediaStreamTrackInterface*>(data);
+      track->Release();*/
       break;
     }
 
     default:
+       printf("default case");
       RTC_NOTREACHED();
       break;
   }
 }
 
 void Conductor::OnSuccess(webrtc::SessionDescriptionInterface* desc) {
+     
+ printf("Setting Local Descriptor...\n\n\n\n\n");
   peer_connection_->SetLocalDescription(
       DummySetSessionDescriptionObserver::Create(), desc);
 
@@ -534,11 +632,14 @@ void Conductor::OnSuccess(webrtc::SessionDescriptionInterface* desc) {
     return;
   }
 
+  printf("Preparing LOCAL DESRCRIPTOR to send\n\n\n\n\n");
+
   Json::StyledWriter writer;
   Json::Value jmessage;
   jmessage[kSessionDescriptionTypeName] =
       webrtc::SdpTypeToString(desc->GetType());
   jmessage[kSessionDescriptionSdpName] = sdp;
+  printf("Sending ............\n\n\n\n\n");
   SendMessage(writer.write(jmessage));
 }
 
@@ -548,5 +649,5 @@ void Conductor::OnFailure(webrtc::RTCError error) {
 
 void Conductor::SendMessage(const std::string& json_object) {
   std::string* msg = new std::string(json_object);
-  main_wnd_->QueueUIThreadCallback(SEND_MESSAGE_TO_PEER, msg);
+  QueueUIThreadCallback(SEND_MESSAGE_TO_PEER, msg);
 }
diff --git a/examples/peerconnection/client/conductor.h b/examples/peerconnection/client/conductor.h
index a038743..f38720c 100644
--- a/examples/peerconnection/client/conductor.h
+++ b/examples/peerconnection/client/conductor.h
@@ -43,7 +43,7 @@ class Conductor : public webrtc::PeerConnectionObserver,
     TRACK_REMOVED,
   };
 
-  Conductor(PeerConnectionClient* client, MainWindow* main_wnd);
+  Conductor(PeerConnectionClient* client);
 
   bool connection_active() const;
 
@@ -103,6 +103,8 @@ class Conductor : public webrtc::PeerConnectionObserver,
   // MainWndCallback implementation.
   //
 
+  public:
+
   void StartLogin(const std::string& server, int port) override;
 
   void DisconnectFromServer() override;
@@ -113,6 +115,8 @@ class Conductor : public webrtc::PeerConnectionObserver,
 
   void UIThreadCallback(int msg_id, void* data) override;
 
+  void QueueUIThreadCallback(int msg_id, void* data);
+
   // CreateSessionDescriptionObserver implementation.
   void OnSuccess(webrtc::SessionDescriptionInterface* desc) override;
   void OnFailure(webrtc::RTCError error) override;
@@ -127,7 +131,7 @@ class Conductor : public webrtc::PeerConnectionObserver,
   rtc::scoped_refptr<webrtc::PeerConnectionFactoryInterface>
       peer_connection_factory_;
   PeerConnectionClient* client_;
-  MainWindow* main_wnd_;
+//  MainWindow* main_wnd_;
   std::deque<std::string*> pending_messages_;
   std::string server_;
 };
diff --git a/examples/peerconnection/client/linux/main.cc b/examples/peerconnection/client/linux/main.cc
index 6c34683..c5483d4 100644
--- a/examples/peerconnection/client/linux/main.cc
+++ b/examples/peerconnection/client/linux/main.cc
@@ -8,31 +8,42 @@
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
-#include <gtk/gtk.h>
+//#include <gtk/gtk.h>
 
 #include "examples/peerconnection/client/conductor.h"
-#include "examples/peerconnection/client/flagdefs.h"
-#include "examples/peerconnection/client/linux/main_wnd.h"
+//#include "examples/peerconnection/client/flagdefs.h"
+//#include "examples/peerconnection/client/linux/main_wnd.h"
 #include "examples/peerconnection/client/peer_connection_client.h"
 
+#include<glib.h>
 #include "rtc_base/ssladapter.h"
 #include "rtc_base/thread.h"
-#include "system_wrappers/include/field_trial.h"
-#include "test/field_trial.h"
+//#include "system_wrappers/include/field_trial.h"
+//#include "test/field_trial.h"
 
 class CustomSocketServer : public rtc::PhysicalSocketServer {
  public:
-  explicit CustomSocketServer(GtkMainWnd* wnd)
-      : wnd_(wnd), conductor_(NULL), client_(NULL) {}
+  explicit CustomSocketServer()
+      : conductor_(NULL), client_(NULL) {
+    printf("Inside constructor CustomSocketServer().....\n");
+}
   virtual ~CustomSocketServer() {}
 
-  void SetMessageQueue(rtc::MessageQueue* queue) override {
-    message_queue_ = queue;
-  }
+//  void SetMessageQueue(rtc::MessageQueue* queue) override {
+  //  message_queue_ = queue;
+ // }
 
   void set_client(PeerConnectionClient* client) { client_ = client; }
   void set_conductor(Conductor* conductor) { conductor_ = conductor; }
 
+
+
+void ConnectToPeer() {
+    printf("Inside ConnectToPeer().....\n");
+    conductor_->ConnectToPeer(1);
+}
+
+
   // Override so that we can also pump the GTK message loop.
   bool Wait(int cms, bool process_io) override {
     // Pump GTK events.
@@ -40,38 +51,51 @@ class CustomSocketServer : public rtc::PhysicalSocketServer {
     // different thread.  Alternatively we could look at merging the two loops
     // by implementing a dispatcher for the socket server and/or use
     // g_main_context_set_poll_func.
-    while (gtk_events_pending())
-      gtk_main_iteration();
+//    while (gtk_events_pending())
+  //    gtk_main_iteration();
 
-    if (!wnd_->IsWindow() && !conductor_->connection_active() &&
+   /* if (!wnd_->IsWindow() && !conductor_->connection_active() &&
         client_ != NULL && !client_->is_connected()) {
-      message_queue_->Quit();
+      message_queue_->Quit();*/
+
+
+    while(g_main_context_pending(NULL)) {
+        printf("PENDING>>:::>>>:::>>::>>::>>THREAD:::>>>>>>>>>>>>>>\n");
+        g_main_context_iteration (NULL, true);
+
     }
     return rtc::PhysicalSocketServer::Wait(0 /*cms == -1 ? 1 : cms*/,
                                            process_io);
   }
+void connectToServer(const std::string& server, int port) {
+      printf("Connecting to Server....\n");
+
+      conductor_->StartLogin(server, port);
+} 
+
 
  protected:
-  rtc::MessageQueue* message_queue_;
-  GtkMainWnd* wnd_;
+//  rtc::MessageQueue* message_queue_;
+    bool connected_Server;
+  //GtkMainWnd* wnd_;
   Conductor* conductor_;
   PeerConnectionClient* client_;
 };
 
 int main(int argc, char* argv[]) {
-  gtk_init(&argc, &argv);
+ // gtk_init(&argc, &argv);
 // g_type_init API is deprecated (and does nothing) since glib 2.35.0, see:
 // https://mail.gnome.org/archives/commits-list/2012-November/msg07809.html
-#if !GLIB_CHECK_VERSION(2, 35, 0)
-  g_type_init();
-#endif
+//#if !GLIB_CHECK_VERSION(2, 35, 0)
+  //g_type_init();
+//#endif
 // g_thread_init API is deprecated since glib 2.31.0, see release note:
 // http://mail.gnome.org/archives/gnome-announce-list/2011-October/msg00041.html
-#if !GLIB_CHECK_VERSION(2, 31, 0)
-  g_thread_init(NULL);
-#endif
+//#if !GLIB_CHECK_VERSION(2, 31, 0)
+//  g_thread_init(NULL);
+//#endif
 
-  rtc::FlagList::SetFlagsFromCommandLine(&argc, argv, true);
+/*  rtc::FlagList::SetFlagsFromCommandLine(&argc, argv, true);
   if (FLAG_help) {
     rtc::FlagList::Print(NULL, false);
     return 0;
@@ -91,22 +115,31 @@ int main(int argc, char* argv[]) {
 
   GtkMainWnd wnd(FLAG_server, FLAG_port, FLAG_autoconnect, FLAG_autocall);
   wnd.Create();
-
-  CustomSocketServer socket_server(&wnd);
+*/
+  CustomSocketServer socket_server;
   rtc::AutoSocketServerThread thread(&socket_server);
+printf("Initialized thread...\n");
 
   rtc::InitializeSSL();
   // Must be constructed after we set the socketserver.
   PeerConnectionClient client;
   rtc::scoped_refptr<Conductor> conductor(
-      new rtc::RefCountedObject<Conductor>(&client, &wnd));
+      new rtc::RefCountedObject<Conductor>(&client));
   socket_server.set_client(&client);
   socket_server.set_conductor(conductor);
-
+  
+  char server_ip[16];
+  int port;
+  printf("Enter server IP Address \n");
+  scanf("%s",server_ip);
+  printf("Enter port number \n");
+  scanf("%d",&port);
+  socket_server.connectToServer(server_ip, port);
   thread.Run();
 
+  printf("After thread.run .......\n");
   // gtk_main();
-  wnd.Destroy();
+ // wnd.Destroy();
 
   // TODO(henrike): Run the Gtk main loop to tear down the connection.
   /*
diff --git a/examples/peerconnection/client/linux/main_wnd.cc b/examples/peerconnection/client/linux/main_wnd.cc
deleted file mode 100644
index 2f7777d..0000000
--- a/examples/peerconnection/client/linux/main_wnd.cc
+++ /dev/null
@@ -1,557 +0,0 @@
-/*
- *  Copyright 2012 The WebRTC Project Authors. All rights reserved.
- *
- *  Use of this source code is governed by a BSD-style license
- *  that can be found in the LICENSE file in the root of the source
- *  tree. An additional intellectual property rights grant can be found
- *  in the file PATENTS.  All contributing project authors may
- *  be found in the AUTHORS file in the root of the source tree.
- */
-
-#include "examples/peerconnection/client/linux/main_wnd.h"
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include <stddef.h>
-
-#include "api/video/i420_buffer.h"
-#include "examples/peerconnection/client/defaults.h"
-#include "rtc_base/checks.h"
-#include "rtc_base/logging.h"
-#include "third_party/libyuv/include/libyuv/convert_from.h"
-
-namespace {
-
-//
-// Simple static functions that simply forward the callback to the
-// GtkMainWnd instance.
-//
-
-gboolean OnDestroyedCallback(GtkWidget* widget,
-                             GdkEvent* event,
-                             gpointer data) {
-  reinterpret_cast<GtkMainWnd*>(data)->OnDestroyed(widget, event);
-  return FALSE;
-}
-
-void OnClickedCallback(GtkWidget* widget, gpointer data) {
-  reinterpret_cast<GtkMainWnd*>(data)->OnClicked(widget);
-}
-
-gboolean SimulateButtonClick(gpointer button) {
-  g_signal_emit_by_name(button, "clicked");
-  return false;
-}
-
-gboolean OnKeyPressCallback(GtkWidget* widget,
-                            GdkEventKey* key,
-                            gpointer data) {
-  reinterpret_cast<GtkMainWnd*>(data)->OnKeyPress(widget, key);
-  return false;
-}
-
-void OnRowActivatedCallback(GtkTreeView* tree_view,
-                            GtkTreePath* path,
-                            GtkTreeViewColumn* column,
-                            gpointer data) {
-  reinterpret_cast<GtkMainWnd*>(data)->OnRowActivated(tree_view, path, column);
-}
-
-gboolean SimulateLastRowActivated(gpointer data) {
-  GtkTreeView* tree_view = reinterpret_cast<GtkTreeView*>(data);
-  GtkTreeModel* model = gtk_tree_view_get_model(tree_view);
-
-  // "if iter is NULL, then the number of toplevel nodes is returned."
-  int rows = gtk_tree_model_iter_n_children(model, NULL);
-  GtkTreePath* lastpath = gtk_tree_path_new_from_indices(rows - 1, -1);
-
-  // Select the last item in the list
-  GtkTreeSelection* selection = gtk_tree_view_get_selection(tree_view);
-  gtk_tree_selection_select_path(selection, lastpath);
-
-  // Our TreeView only has one column, so it is column 0.
-  GtkTreeViewColumn* column = gtk_tree_view_get_column(tree_view, 0);
-
-  gtk_tree_view_row_activated(tree_view, lastpath, column);
-
-  gtk_tree_path_free(lastpath);
-  return false;
-}
-
-// Creates a tree view, that we use to display the list of peers.
-void InitializeList(GtkWidget* list) {
-  GtkCellRenderer* renderer = gtk_cell_renderer_text_new();
-  GtkTreeViewColumn* column = gtk_tree_view_column_new_with_attributes(
-      "List Items", renderer, "text", 0, NULL);
-  gtk_tree_view_append_column(GTK_TREE_VIEW(list), column);
-  GtkListStore* store = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_INT);
-  gtk_tree_view_set_model(GTK_TREE_VIEW(list), GTK_TREE_MODEL(store));
-  g_object_unref(store);
-}
-
-// Adds an entry to a tree view.
-void AddToList(GtkWidget* list, const gchar* str, int value) {
-  GtkListStore* store =
-      GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(list)));
-
-  GtkTreeIter iter;
-  gtk_list_store_append(store, &iter);
-  gtk_list_store_set(store, &iter, 0, str, 1, value, -1);
-}
-
-struct UIThreadCallbackData {
-  explicit UIThreadCallbackData(MainWndCallback* cb, int id, void* d)
-      : callback(cb), msg_id(id), data(d) {}
-  MainWndCallback* callback;
-  int msg_id;
-  void* data;
-};
-
-gboolean HandleUIThreadCallback(gpointer data) {
-  UIThreadCallbackData* cb_data = reinterpret_cast<UIThreadCallbackData*>(data);
-  cb_data->callback->UIThreadCallback(cb_data->msg_id, cb_data->data);
-  delete cb_data;
-  return false;
-}
-
-gboolean Redraw(gpointer data) {
-  GtkMainWnd* wnd = reinterpret_cast<GtkMainWnd*>(data);
-  wnd->OnRedraw();
-  return false;
-}
-
-gboolean Draw(GtkWidget* widget, cairo_t* cr, gpointer data) {
-  GtkMainWnd* wnd = reinterpret_cast<GtkMainWnd*>(data);
-  wnd->Draw(widget, cr);
-  return false;
-}
-
-}  // namespace
-
-//
-// GtkMainWnd implementation.
-//
-
-GtkMainWnd::GtkMainWnd(const char* server,
-                       int port,
-                       bool autoconnect,
-                       bool autocall)
-    : window_(NULL),
-      draw_area_(NULL),
-      vbox_(NULL),
-      server_edit_(NULL),
-      port_edit_(NULL),
-      peer_list_(NULL),
-      callback_(NULL),
-      server_(server),
-      autoconnect_(autoconnect),
-      autocall_(autocall) {
-  char buffer[10];
-  snprintf(buffer, sizeof(buffer), "%i", port);
-  port_ = buffer;
-}
-
-GtkMainWnd::~GtkMainWnd() {
-  RTC_DCHECK(!IsWindow());
-}
-
-void GtkMainWnd::RegisterObserver(MainWndCallback* callback) {
-  callback_ = callback;
-}
-
-bool GtkMainWnd::IsWindow() {
-  return window_ != NULL && GTK_IS_WINDOW(window_);
-}
-
-void GtkMainWnd::MessageBox(const char* caption,
-                            const char* text,
-                            bool is_error) {
-  GtkWidget* dialog = gtk_message_dialog_new(
-      GTK_WINDOW(window_), GTK_DIALOG_DESTROY_WITH_PARENT,
-      is_error ? GTK_MESSAGE_ERROR : GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, "%s",
-      text);
-  gtk_window_set_title(GTK_WINDOW(dialog), caption);
-  gtk_dialog_run(GTK_DIALOG(dialog));
-  gtk_widget_destroy(dialog);
-}
-
-MainWindow::UI GtkMainWnd::current_ui() {
-  if (vbox_)
-    return CONNECT_TO_SERVER;
-
-  if (peer_list_)
-    return LIST_PEERS;
-
-  return STREAMING;
-}
-
-void GtkMainWnd::StartLocalRenderer(webrtc::VideoTrackInterface* local_video) {
-  local_renderer_.reset(new VideoRenderer(this, local_video));
-}
-
-void GtkMainWnd::StopLocalRenderer() {
-  local_renderer_.reset();
-}
-
-void GtkMainWnd::StartRemoteRenderer(
-    webrtc::VideoTrackInterface* remote_video) {
-  remote_renderer_.reset(new VideoRenderer(this, remote_video));
-}
-
-void GtkMainWnd::StopRemoteRenderer() {
-  remote_renderer_.reset();
-}
-
-void GtkMainWnd::QueueUIThreadCallback(int msg_id, void* data) {
-  g_idle_add(HandleUIThreadCallback,
-             new UIThreadCallbackData(callback_, msg_id, data));
-}
-
-bool GtkMainWnd::Create() {
-  RTC_DCHECK(window_ == NULL);
-
-  window_ = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-  if (window_) {
-    gtk_window_set_position(GTK_WINDOW(window_), GTK_WIN_POS_CENTER);
-    gtk_window_set_default_size(GTK_WINDOW(window_), 640, 480);
-    gtk_window_set_title(GTK_WINDOW(window_), "PeerConnection client");
-    g_signal_connect(G_OBJECT(window_), "delete-event",
-                     G_CALLBACK(&OnDestroyedCallback), this);
-    g_signal_connect(window_, "key-press-event", G_CALLBACK(OnKeyPressCallback),
-                     this);
-
-    SwitchToConnectUI();
-  }
-
-  return window_ != NULL;
-}
-
-bool GtkMainWnd::Destroy() {
-  if (!IsWindow())
-    return false;
-
-  gtk_widget_destroy(window_);
-  window_ = NULL;
-
-  return true;
-}
-
-void GtkMainWnd::SwitchToConnectUI() {
-  RTC_LOG(INFO) << __FUNCTION__;
-
-  RTC_DCHECK(IsWindow());
-  RTC_DCHECK(vbox_ == NULL);
-
-  gtk_container_set_border_width(GTK_CONTAINER(window_), 10);
-
-  if (peer_list_) {
-    gtk_widget_destroy(peer_list_);
-    peer_list_ = NULL;
-  }
-
-#if GTK_MAJOR_VERSION == 2
-  vbox_ = gtk_vbox_new(FALSE, 5);
-#else
-  vbox_ = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
-#endif
-  GtkWidget* valign = gtk_alignment_new(0, 1, 0, 0);
-  gtk_container_add(GTK_CONTAINER(vbox_), valign);
-  gtk_container_add(GTK_CONTAINER(window_), vbox_);
-
-#if GTK_MAJOR_VERSION == 2
-  GtkWidget* hbox = gtk_hbox_new(FALSE, 5);
-#else
-  GtkWidget* hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
-#endif
-
-  GtkWidget* label = gtk_label_new("Server");
-  gtk_container_add(GTK_CONTAINER(hbox), label);
-
-  server_edit_ = gtk_entry_new();
-  gtk_entry_set_text(GTK_ENTRY(server_edit_), server_.c_str());
-  gtk_widget_set_size_request(server_edit_, 400, 30);
-  gtk_container_add(GTK_CONTAINER(hbox), server_edit_);
-
-  port_edit_ = gtk_entry_new();
-  gtk_entry_set_text(GTK_ENTRY(port_edit_), port_.c_str());
-  gtk_widget_set_size_request(port_edit_, 70, 30);
-  gtk_container_add(GTK_CONTAINER(hbox), port_edit_);
-
-  GtkWidget* button = gtk_button_new_with_label("Connect");
-  gtk_widget_set_size_request(button, 70, 30);
-  g_signal_connect(button, "clicked", G_CALLBACK(OnClickedCallback), this);
-  gtk_container_add(GTK_CONTAINER(hbox), button);
-
-  GtkWidget* halign = gtk_alignment_new(1, 0, 0, 0);
-  gtk_container_add(GTK_CONTAINER(halign), hbox);
-  gtk_box_pack_start(GTK_BOX(vbox_), halign, FALSE, FALSE, 0);
-
-  gtk_widget_show_all(window_);
-
-  if (autoconnect_)
-    g_idle_add(SimulateButtonClick, button);
-}
-
-void GtkMainWnd::SwitchToPeerList(const Peers& peers) {
-  RTC_LOG(INFO) << __FUNCTION__;
-
-  if (!peer_list_) {
-    gtk_container_set_border_width(GTK_CONTAINER(window_), 0);
-    if (vbox_) {
-      gtk_widget_destroy(vbox_);
-      vbox_ = NULL;
-      server_edit_ = NULL;
-      port_edit_ = NULL;
-    } else if (draw_area_) {
-      gtk_widget_destroy(draw_area_);
-      draw_area_ = NULL;
-      draw_buffer_.reset();
-    }
-
-    peer_list_ = gtk_tree_view_new();
-    g_signal_connect(peer_list_, "row-activated",
-                     G_CALLBACK(OnRowActivatedCallback), this);
-    gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(peer_list_), FALSE);
-    InitializeList(peer_list_);
-    gtk_container_add(GTK_CONTAINER(window_), peer_list_);
-    gtk_widget_show_all(window_);
-  } else {
-    GtkListStore* store =
-        GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(peer_list_)));
-    gtk_list_store_clear(store);
-  }
-
-  AddToList(peer_list_, "List of currently connected peers:", -1);
-  for (Peers::const_iterator i = peers.begin(); i != peers.end(); ++i)
-    AddToList(peer_list_, i->second.c_str(), i->first);
-
-  if (autocall_ && peers.begin() != peers.end())
-    g_idle_add(SimulateLastRowActivated, peer_list_);
-}
-
-void GtkMainWnd::SwitchToStreamingUI() {
-  RTC_LOG(INFO) << __FUNCTION__;
-
-  RTC_DCHECK(draw_area_ == NULL);
-
-  gtk_container_set_border_width(GTK_CONTAINER(window_), 0);
-  if (peer_list_) {
-    gtk_widget_destroy(peer_list_);
-    peer_list_ = NULL;
-  }
-
-  draw_area_ = gtk_drawing_area_new();
-  gtk_container_add(GTK_CONTAINER(window_), draw_area_);
-  g_signal_connect(G_OBJECT(draw_area_), "draw", G_CALLBACK(&::Draw), this);
-
-  gtk_widget_show_all(window_);
-}
-
-void GtkMainWnd::OnDestroyed(GtkWidget* widget, GdkEvent* event) {
-  callback_->Close();
-  window_ = NULL;
-  draw_area_ = NULL;
-  vbox_ = NULL;
-  server_edit_ = NULL;
-  port_edit_ = NULL;
-  peer_list_ = NULL;
-}
-
-void GtkMainWnd::OnClicked(GtkWidget* widget) {
-  // Make the connect button insensitive, so that it cannot be clicked more than
-  // once.  Now that the connection includes auto-retry, it should not be
-  // necessary to click it more than once.
-  gtk_widget_set_sensitive(widget, false);
-  server_ = gtk_entry_get_text(GTK_ENTRY(server_edit_));
-  port_ = gtk_entry_get_text(GTK_ENTRY(port_edit_));
-  int port = port_.length() ? atoi(port_.c_str()) : 0;
-  callback_->StartLogin(server_, port);
-}
-
-void GtkMainWnd::OnKeyPress(GtkWidget* widget, GdkEventKey* key) {
-  if (key->type == GDK_KEY_PRESS) {
-    switch (key->keyval) {
-#if GTK_MAJOR_VERSION == 2
-      case GDK_Escape:
-#else
-      case GDK_KEY_Escape:
-#endif
-        if (draw_area_) {
-          callback_->DisconnectFromCurrentPeer();
-        } else if (peer_list_) {
-          callback_->DisconnectFromServer();
-        }
-        break;
-
-#if GTK_MAJOR_VERSION == 2
-      case GDK_KP_Enter:
-      case GDK_Return:
-#else
-      case GDK_KEY_KP_Enter:
-      case GDK_KEY_Return:
-#endif
-        if (vbox_) {
-          OnClicked(NULL);
-        } else if (peer_list_) {
-          // OnRowActivated will be called automatically when the user
-          // presses enter.
-        }
-        break;
-
-      default:
-        break;
-    }
-  }
-}
-
-void GtkMainWnd::OnRowActivated(GtkTreeView* tree_view,
-                                GtkTreePath* path,
-                                GtkTreeViewColumn* column) {
-  RTC_DCHECK(peer_list_ != NULL);
-  GtkTreeIter iter;
-  GtkTreeModel* model;
-  GtkTreeSelection* selection =
-      gtk_tree_view_get_selection(GTK_TREE_VIEW(tree_view));
-  if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
-    char* text;
-    int id = -1;
-    gtk_tree_model_get(model, &iter, 0, &text, 1, &id, -1);
-    if (id != -1)
-      callback_->ConnectToPeer(id);
-    g_free(text);
-  }
-}
-
-void GtkMainWnd::OnRedraw() {
-  gdk_threads_enter();
-
-  VideoRenderer* remote_renderer = remote_renderer_.get();
-  if (remote_renderer && remote_renderer->image() != NULL &&
-      draw_area_ != NULL) {
-    width_ = remote_renderer->width();
-    height_ = remote_renderer->height();
-
-    if (!draw_buffer_.get()) {
-      draw_buffer_size_ = (width_ * height_ * 4) * 4;
-      draw_buffer_.reset(new uint8_t[draw_buffer_size_]);
-      gtk_widget_set_size_request(draw_area_, width_ * 2, height_ * 2);
-    }
-
-    const uint32_t* image =
-        reinterpret_cast<const uint32_t*>(remote_renderer->image());
-    uint32_t* scaled = reinterpret_cast<uint32_t*>(draw_buffer_.get());
-    for (int r = 0; r < height_; ++r) {
-      for (int c = 0; c < width_; ++c) {
-        int x = c * 2;
-        scaled[x] = scaled[x + 1] = image[c];
-      }
-
-      uint32_t* prev_line = scaled;
-      scaled += width_ * 2;
-      memcpy(scaled, prev_line, (width_ * 2) * 4);
-
-      image += width_;
-      scaled += width_ * 2;
-    }
-
-    VideoRenderer* local_renderer = local_renderer_.get();
-    if (local_renderer && local_renderer->image()) {
-      image = reinterpret_cast<const uint32_t*>(local_renderer->image());
-      scaled = reinterpret_cast<uint32_t*>(draw_buffer_.get());
-      // Position the local preview on the right side.
-      scaled += (width_ * 2) - (local_renderer->width() / 2);
-      // right margin...
-      scaled -= 10;
-      // ... towards the bottom.
-      scaled += (height_ * width_ * 4) - ((local_renderer->height() / 2) *
-                                          (local_renderer->width() / 2) * 4);
-      // bottom margin...
-      scaled -= (width_ * 2) * 5;
-      for (int r = 0; r < local_renderer->height(); r += 2) {
-        for (int c = 0; c < local_renderer->width(); c += 2) {
-          scaled[c / 2] = image[c + r * local_renderer->width()];
-        }
-        scaled += width_ * 2;
-      }
-    }
-
-#if GTK_MAJOR_VERSION == 2
-    gdk_draw_rgb_32_image(draw_area_->window,
-                          draw_area_->style->fg_gc[GTK_STATE_NORMAL], 0, 0,
-                          width_ * 2, height_ * 2, GDK_RGB_DITHER_MAX,
-                          draw_buffer_.get(), (width_ * 2) * 4);
-#else
-    gtk_widget_queue_draw(draw_area_);
-#endif
-  }
-
-  gdk_threads_leave();
-}
-
-void GtkMainWnd::Draw(GtkWidget* widget, cairo_t* cr) {
-#if GTK_MAJOR_VERSION != 2
-  cairo_format_t format = CAIRO_FORMAT_RGB24;
-  cairo_surface_t* surface = cairo_image_surface_create_for_data(
-      draw_buffer_.get(), format, width_ * 2, height_ * 2,
-      cairo_format_stride_for_width(format, width_ * 2));
-  cairo_set_source_surface(cr, surface, 0, 0);
-  cairo_rectangle(cr, 0, 0, width_ * 2, height_ * 2);
-  cairo_fill(cr);
-  cairo_surface_destroy(surface);
-#else
-  RTC_NOTREACHED();
-#endif
-}
-
-GtkMainWnd::VideoRenderer::VideoRenderer(
-    GtkMainWnd* main_wnd,
-    webrtc::VideoTrackInterface* track_to_render)
-    : width_(0),
-      height_(0),
-      main_wnd_(main_wnd),
-      rendered_track_(track_to_render) {
-  rendered_track_->AddOrUpdateSink(this, rtc::VideoSinkWants());
-}
-
-GtkMainWnd::VideoRenderer::~VideoRenderer() {
-  rendered_track_->RemoveSink(this);
-}
-
-void GtkMainWnd::VideoRenderer::SetSize(int width, int height) {
-  gdk_threads_enter();
-
-  if (width_ == width && height_ == height) {
-    return;
-  }
-
-  width_ = width;
-  height_ = height;
-  image_.reset(new uint8_t[width * height * 4]);
-  gdk_threads_leave();
-}
-
-void GtkMainWnd::VideoRenderer::OnFrame(const webrtc::VideoFrame& video_frame) {
-  gdk_threads_enter();
-
-  rtc::scoped_refptr<webrtc::I420BufferInterface> buffer(
-      video_frame.video_frame_buffer()->ToI420());
-  if (video_frame.rotation() != webrtc::kVideoRotation_0) {
-    buffer = webrtc::I420Buffer::Rotate(*buffer, video_frame.rotation());
-  }
-  SetSize(buffer->width(), buffer->height());
-
-  // The order in the name of libyuv::I420To(ABGR,RGBA) is ambiguous because
-  // it doesn't tell you if it is referring to how it is laid out in memory as
-  // bytes or if endiannes is taken into account.
-  // This was supposed to be a call to libyuv::I420ToRGBA but it was resulting
-  // in a reddish video output (see https://bugs.webrtc.org/6857) because it
-  // was producing an unexpected byte order (ABGR, byte swapped).
-  libyuv::I420ToABGR(buffer->DataY(), buffer->StrideY(), buffer->DataU(),
-                     buffer->StrideU(), buffer->DataV(), buffer->StrideV(),
-                     image_.get(), width_ * 4, buffer->width(),
-                     buffer->height());
-
-  gdk_threads_leave();
-
-  g_idle_add(Redraw, main_wnd_);
-}
diff --git a/examples/peerconnection/client/linux/main_wnd.h b/examples/peerconnection/client/linux/main_wnd.h
deleted file mode 100644
index a2edb74..0000000
--- a/examples/peerconnection/client/linux/main_wnd.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- *  Copyright 2012 The WebRTC Project Authors. All rights reserved.
- *
- *  Use of this source code is governed by a BSD-style license
- *  that can be found in the LICENSE file in the root of the source
- *  tree. An additional intellectual property rights grant can be found
- *  in the file PATENTS.  All contributing project authors may
- *  be found in the AUTHORS file in the root of the source tree.
- */
-
-#ifndef EXAMPLES_PEERCONNECTION_CLIENT_LINUX_MAIN_WND_H_
-#define EXAMPLES_PEERCONNECTION_CLIENT_LINUX_MAIN_WND_H_
-
-#include <memory>
-#include <string>
-
-#include "examples/peerconnection/client/main_wnd.h"
-#include "examples/peerconnection/client/peer_connection_client.h"
-
-// Forward declarations.
-typedef struct _GtkWidget GtkWidget;
-typedef union _GdkEvent GdkEvent;
-typedef struct _GdkEventKey GdkEventKey;
-typedef struct _GtkTreeView GtkTreeView;
-typedef struct _GtkTreePath GtkTreePath;
-typedef struct _GtkTreeViewColumn GtkTreeViewColumn;
-typedef struct _cairo cairo_t;
-
-// Implements the main UI of the peer connection client.
-// This is functionally equivalent to the MainWnd class in the Windows
-// implementation.
-class GtkMainWnd : public MainWindow {
- public:
-  GtkMainWnd(const char* server, int port, bool autoconnect, bool autocall);
-  ~GtkMainWnd();
-
-  virtual void RegisterObserver(MainWndCallback* callback);
-  virtual bool IsWindow();
-  virtual void SwitchToConnectUI();
-  virtual void SwitchToPeerList(const Peers& peers);
-  virtual void SwitchToStreamingUI();
-  virtual void MessageBox(const char* caption, const char* text, bool is_error);
-  virtual MainWindow::UI current_ui();
-  virtual void StartLocalRenderer(webrtc::VideoTrackInterface* local_video);
-  virtual void StopLocalRenderer();
-  virtual void StartRemoteRenderer(webrtc::VideoTrackInterface* remote_video);
-  virtual void StopRemoteRenderer();
-
-  virtual void QueueUIThreadCallback(int msg_id, void* data);
-
-  // Creates and shows the main window with the |Connect UI| enabled.
-  bool Create();
-
-  // Destroys the window.  When the window is destroyed, it ends the
-  // main message loop.
-  bool Destroy();
-
-  // Callback for when the main window is destroyed.
-  void OnDestroyed(GtkWidget* widget, GdkEvent* event);
-
-  // Callback for when the user clicks the "Connect" button.
-  void OnClicked(GtkWidget* widget);
-
-  // Callback for keystrokes.  Used to capture Esc and Return.
-  void OnKeyPress(GtkWidget* widget, GdkEventKey* key);
-
-  // Callback when the user double clicks a peer in order to initiate a
-  // connection.
-  void OnRowActivated(GtkTreeView* tree_view,
-                      GtkTreePath* path,
-                      GtkTreeViewColumn* column);
-
-  void OnRedraw();
-
-  void Draw(GtkWidget* widget, cairo_t* cr);
-
- protected:
-  class VideoRenderer : public rtc::VideoSinkInterface<webrtc::VideoFrame> {
-   public:
-    VideoRenderer(GtkMainWnd* main_wnd,
-                  webrtc::VideoTrackInterface* track_to_render);
-    virtual ~VideoRenderer();
-
-    // VideoSinkInterface implementation
-    void OnFrame(const webrtc::VideoFrame& frame) override;
-
-    const uint8_t* image() const { return image_.get(); }
-
-    int width() const { return width_; }
-
-    int height() const { return height_; }
-
-   protected:
-    void SetSize(int width, int height);
-    std::unique_ptr<uint8_t[]> image_;
-    int width_;
-    int height_;
-    GtkMainWnd* main_wnd_;
-    rtc::scoped_refptr<webrtc::VideoTrackInterface> rendered_track_;
-  };
-
- protected:
-  GtkWidget* window_;     // Our main window.
-  GtkWidget* draw_area_;  // The drawing surface for rendering video streams.
-  GtkWidget* vbox_;       // Container for the Connect UI.
-  GtkWidget* server_edit_;
-  GtkWidget* port_edit_;
-  GtkWidget* peer_list_;  // The list of peers.
-  MainWndCallback* callback_;
-  std::string server_;
-  std::string port_;
-  bool autoconnect_;
-  bool autocall_;
-  std::unique_ptr<VideoRenderer> local_renderer_;
-  std::unique_ptr<VideoRenderer> remote_renderer_;
-  int width_;
-  int height_;
-  std::unique_ptr<uint8_t[]> draw_buffer_;
-  int draw_buffer_size_;
-};
-
-#endif  // EXAMPLES_PEERCONNECTION_CLIENT_LINUX_MAIN_WND_H_
diff --git a/examples/peerconnection/client/main_wnd.cc b/examples/peerconnection/client/main_wnd.cc
deleted file mode 100644
index 8edd1e7..0000000
--- a/examples/peerconnection/client/main_wnd.cc
+++ /dev/null
@@ -1,633 +0,0 @@
-/*
- *  Copyright 2012 The WebRTC Project Authors. All rights reserved.
- *
- *  Use of this source code is governed by a BSD-style license
- *  that can be found in the LICENSE file in the root of the source
- *  tree. An additional intellectual property rights grant can be found
- *  in the file PATENTS.  All contributing project authors may
- *  be found in the AUTHORS file in the root of the source tree.
- */
-
-#include "examples/peerconnection/client/main_wnd.h"
-
-#include <math.h>
-
-#include "api/video/i420_buffer.h"
-#include "examples/peerconnection/client/defaults.h"
-#include "rtc_base/arraysize.h"
-#include "rtc_base/checks.h"
-#include "rtc_base/logging.h"
-#include "third_party/libyuv/include/libyuv/convert_argb.h"
-
-ATOM MainWnd::wnd_class_ = 0;
-const wchar_t MainWnd::kClassName[] = L"WebRTC_MainWnd";
-
-namespace {
-
-const char kConnecting[] = "Connecting... ";
-const char kNoVideoStreams[] = "(no video streams either way)";
-const char kNoIncomingStream[] = "(no incoming video)";
-
-void CalculateWindowSizeForText(HWND wnd,
-                                const wchar_t* text,
-                                size_t* width,
-                                size_t* height) {
-  HDC dc = ::GetDC(wnd);
-  RECT text_rc = {0};
-  ::DrawText(dc, text, -1, &text_rc, DT_CALCRECT | DT_SINGLELINE);
-  ::ReleaseDC(wnd, dc);
-  RECT client, window;
-  ::GetClientRect(wnd, &client);
-  ::GetWindowRect(wnd, &window);
-
-  *width = text_rc.right - text_rc.left;
-  *width += (window.right - window.left) - (client.right - client.left);
-  *height = text_rc.bottom - text_rc.top;
-  *height += (window.bottom - window.top) - (client.bottom - client.top);
-}
-
-HFONT GetDefaultFont() {
-  static HFONT font = reinterpret_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
-  return font;
-}
-
-std::string GetWindowText(HWND wnd) {
-  char text[MAX_PATH] = {0};
-  ::GetWindowTextA(wnd, &text[0], ARRAYSIZE(text));
-  return text;
-}
-
-void AddListBoxItem(HWND listbox, const std::string& str, LPARAM item_data) {
-  LRESULT index = ::SendMessageA(listbox, LB_ADDSTRING, 0,
-                                 reinterpret_cast<LPARAM>(str.c_str()));
-  ::SendMessageA(listbox, LB_SETITEMDATA, index, item_data);
-}
-
-}  // namespace
-
-MainWnd::MainWnd(const char* server,
-                 int port,
-                 bool auto_connect,
-                 bool auto_call)
-    : ui_(CONNECT_TO_SERVER),
-      wnd_(NULL),
-      edit1_(NULL),
-      edit2_(NULL),
-      label1_(NULL),
-      label2_(NULL),
-      button_(NULL),
-      listbox_(NULL),
-      destroyed_(false),
-      nested_msg_(NULL),
-      callback_(NULL),
-      server_(server),
-      auto_connect_(auto_connect),
-      auto_call_(auto_call) {
-  char buffer[10];
-  snprintf(buffer, sizeof(buffer), "%i", port);
-  port_ = buffer;
-}
-
-MainWnd::~MainWnd() {
-  RTC_DCHECK(!IsWindow());
-}
-
-bool MainWnd::Create() {
-  RTC_DCHECK(wnd_ == NULL);
-  if (!RegisterWindowClass())
-    return false;
-
-  ui_thread_id_ = ::GetCurrentThreadId();
-  wnd_ =
-      ::CreateWindowExW(WS_EX_OVERLAPPEDWINDOW, kClassName, L"WebRTC",
-                        WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
-                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
-                        CW_USEDEFAULT, NULL, NULL, GetModuleHandle(NULL), this);
-
-  ::SendMessage(wnd_, WM_SETFONT, reinterpret_cast<WPARAM>(GetDefaultFont()),
-                TRUE);
-
-  CreateChildWindows();
-  SwitchToConnectUI();
-
-  return wnd_ != NULL;
-}
-
-bool MainWnd::Destroy() {
-  BOOL ret = FALSE;
-  if (IsWindow()) {
-    ret = ::DestroyWindow(wnd_);
-  }
-
-  return ret != FALSE;
-}
-
-void MainWnd::RegisterObserver(MainWndCallback* callback) {
-  callback_ = callback;
-}
-
-bool MainWnd::IsWindow() {
-  return wnd_ && ::IsWindow(wnd_) != FALSE;
-}
-
-bool MainWnd::PreTranslateMessage(MSG* msg) {
-  bool ret = false;
-  if (msg->message == WM_CHAR) {
-    if (msg->wParam == VK_TAB) {
-      HandleTabbing();
-      ret = true;
-    } else if (msg->wParam == VK_RETURN) {
-      OnDefaultAction();
-      ret = true;
-    } else if (msg->wParam == VK_ESCAPE) {
-      if (callback_) {
-        if (ui_ == STREAMING) {
-          callback_->DisconnectFromCurrentPeer();
-        } else {
-          callback_->DisconnectFromServer();
-        }
-      }
-    }
-  } else if (msg->hwnd == NULL && msg->message == UI_THREAD_CALLBACK) {
-    callback_->UIThreadCallback(static_cast<int>(msg->wParam),
-                                reinterpret_cast<void*>(msg->lParam));
-    ret = true;
-  }
-  return ret;
-}
-
-void MainWnd::SwitchToConnectUI() {
-  RTC_DCHECK(IsWindow());
-  LayoutPeerListUI(false);
-  ui_ = CONNECT_TO_SERVER;
-  LayoutConnectUI(true);
-  ::SetFocus(edit1_);
-
-  if (auto_connect_)
-    ::PostMessage(button_, BM_CLICK, 0, 0);
-}
-
-void MainWnd::SwitchToPeerList(const Peers& peers) {
-  LayoutConnectUI(false);
-
-  ::SendMessage(listbox_, LB_RESETCONTENT, 0, 0);
-
-  AddListBoxItem(listbox_, "List of currently connected peers:", -1);
-  Peers::const_iterator i = peers.begin();
-  for (; i != peers.end(); ++i)
-    AddListBoxItem(listbox_, i->second.c_str(), i->first);
-
-  ui_ = LIST_PEERS;
-  LayoutPeerListUI(true);
-  ::SetFocus(listbox_);
-
-  if (auto_call_ && peers.begin() != peers.end()) {
-    // Get the number of items in the list
-    LRESULT count = ::SendMessage(listbox_, LB_GETCOUNT, 0, 0);
-    if (count != LB_ERR) {
-      // Select the last item in the list
-      LRESULT selection = ::SendMessage(listbox_, LB_SETCURSEL, count - 1, 0);
-      if (selection != LB_ERR)
-        ::PostMessage(wnd_, WM_COMMAND,
-                      MAKEWPARAM(GetDlgCtrlID(listbox_), LBN_DBLCLK),
-                      reinterpret_cast<LPARAM>(listbox_));
-    }
-  }
-}
-
-void MainWnd::SwitchToStreamingUI() {
-  LayoutConnectUI(false);
-  LayoutPeerListUI(false);
-  ui_ = STREAMING;
-}
-
-void MainWnd::MessageBox(const char* caption, const char* text, bool is_error) {
-  DWORD flags = MB_OK;
-  if (is_error)
-    flags |= MB_ICONERROR;
-
-  ::MessageBoxA(handle(), text, caption, flags);
-}
-
-void MainWnd::StartLocalRenderer(webrtc::VideoTrackInterface* local_video) {
-  local_renderer_.reset(new VideoRenderer(handle(), 1, 1, local_video));
-}
-
-void MainWnd::StopLocalRenderer() {
-  local_renderer_.reset();
-}
-
-void MainWnd::StartRemoteRenderer(webrtc::VideoTrackInterface* remote_video) {
-  remote_renderer_.reset(new VideoRenderer(handle(), 1, 1, remote_video));
-}
-
-void MainWnd::StopRemoteRenderer() {
-  remote_renderer_.reset();
-}
-
-void MainWnd::QueueUIThreadCallback(int msg_id, void* data) {
-  ::PostThreadMessage(ui_thread_id_, UI_THREAD_CALLBACK,
-                      static_cast<WPARAM>(msg_id),
-                      reinterpret_cast<LPARAM>(data));
-}
-
-void MainWnd::OnPaint() {
-  PAINTSTRUCT ps;
-  ::BeginPaint(handle(), &ps);
-
-  RECT rc;
-  ::GetClientRect(handle(), &rc);
-
-  VideoRenderer* local_renderer = local_renderer_.get();
-  VideoRenderer* remote_renderer = remote_renderer_.get();
-  if (ui_ == STREAMING && remote_renderer && local_renderer) {
-    AutoLock<VideoRenderer> local_lock(local_renderer);
-    AutoLock<VideoRenderer> remote_lock(remote_renderer);
-
-    const BITMAPINFO& bmi = remote_renderer->bmi();
-    int height = abs(bmi.bmiHeader.biHeight);
-    int width = bmi.bmiHeader.biWidth;
-
-    const uint8_t* image = remote_renderer->image();
-    if (image != NULL) {
-      HDC dc_mem = ::CreateCompatibleDC(ps.hdc);
-      ::SetStretchBltMode(dc_mem, HALFTONE);
-
-      // Set the map mode so that the ratio will be maintained for us.
-      HDC all_dc[] = {ps.hdc, dc_mem};
-      for (size_t i = 0; i < arraysize(all_dc); ++i) {
-        SetMapMode(all_dc[i], MM_ISOTROPIC);
-        SetWindowExtEx(all_dc[i], width, height, NULL);
-        SetViewportExtEx(all_dc[i], rc.right, rc.bottom, NULL);
-      }
-
-      HBITMAP bmp_mem = ::CreateCompatibleBitmap(ps.hdc, rc.right, rc.bottom);
-      HGDIOBJ bmp_old = ::SelectObject(dc_mem, bmp_mem);
-
-      POINT logical_area = {rc.right, rc.bottom};
-      DPtoLP(ps.hdc, &logical_area, 1);
-
-      HBRUSH brush = ::CreateSolidBrush(RGB(0, 0, 0));
-      RECT logical_rect = {0, 0, logical_area.x, logical_area.y};
-      ::FillRect(dc_mem, &logical_rect, brush);
-      ::DeleteObject(brush);
-
-      int x = (logical_area.x / 2) - (width / 2);
-      int y = (logical_area.y / 2) - (height / 2);
-
-      StretchDIBits(dc_mem, x, y, width, height, 0, 0, width, height, image,
-                    &bmi, DIB_RGB_COLORS, SRCCOPY);
-
-      if ((rc.right - rc.left) > 200 && (rc.bottom - rc.top) > 200) {
-        const BITMAPINFO& bmi = local_renderer->bmi();
-        image = local_renderer->image();
-        int thumb_width = bmi.bmiHeader.biWidth / 4;
-        int thumb_height = abs(bmi.bmiHeader.biHeight) / 4;
-        StretchDIBits(dc_mem, logical_area.x - thumb_width - 10,
-                      logical_area.y - thumb_height - 10, thumb_width,
-                      thumb_height, 0, 0, bmi.bmiHeader.biWidth,
-                      -bmi.bmiHeader.biHeight, image, &bmi, DIB_RGB_COLORS,
-                      SRCCOPY);
-      }
-
-      BitBlt(ps.hdc, 0, 0, logical_area.x, logical_area.y, dc_mem, 0, 0,
-             SRCCOPY);
-
-      // Cleanup.
-      ::SelectObject(dc_mem, bmp_old);
-      ::DeleteObject(bmp_mem);
-      ::DeleteDC(dc_mem);
-    } else {
-      // We're still waiting for the video stream to be initialized.
-      HBRUSH brush = ::CreateSolidBrush(RGB(0, 0, 0));
-      ::FillRect(ps.hdc, &rc, brush);
-      ::DeleteObject(brush);
-
-      HGDIOBJ old_font = ::SelectObject(ps.hdc, GetDefaultFont());
-      ::SetTextColor(ps.hdc, RGB(0xff, 0xff, 0xff));
-      ::SetBkMode(ps.hdc, TRANSPARENT);
-
-      std::string text(kConnecting);
-      if (!local_renderer->image()) {
-        text += kNoVideoStreams;
-      } else {
-        text += kNoIncomingStream;
-      }
-      ::DrawTextA(ps.hdc, text.c_str(), -1, &rc,
-                  DT_SINGLELINE | DT_CENTER | DT_VCENTER);
-      ::SelectObject(ps.hdc, old_font);
-    }
-  } else {
-    HBRUSH brush = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
-    ::FillRect(ps.hdc, &rc, brush);
-    ::DeleteObject(brush);
-  }
-
-  ::EndPaint(handle(), &ps);
-}
-
-void MainWnd::OnDestroyed() {
-  PostQuitMessage(0);
-}
-
-void MainWnd::OnDefaultAction() {
-  if (!callback_)
-    return;
-  if (ui_ == CONNECT_TO_SERVER) {
-    std::string server(GetWindowText(edit1_));
-    std::string port_str(GetWindowText(edit2_));
-    int port = port_str.length() ? atoi(port_str.c_str()) : 0;
-    callback_->StartLogin(server, port);
-  } else if (ui_ == LIST_PEERS) {
-    LRESULT sel = ::SendMessage(listbox_, LB_GETCURSEL, 0, 0);
-    if (sel != LB_ERR) {
-      LRESULT peer_id = ::SendMessage(listbox_, LB_GETITEMDATA, sel, 0);
-      if (peer_id != -1 && callback_) {
-        callback_->ConnectToPeer(peer_id);
-      }
-    }
-  } else {
-    MessageBoxA(wnd_, "OK!", "Yeah", MB_OK);
-  }
-}
-
-bool MainWnd::OnMessage(UINT msg, WPARAM wp, LPARAM lp, LRESULT* result) {
-  switch (msg) {
-    case WM_ERASEBKGND:
-      *result = TRUE;
-      return true;
-
-    case WM_PAINT:
-      OnPaint();
-      return true;
-
-    case WM_SETFOCUS:
-      if (ui_ == CONNECT_TO_SERVER) {
-        SetFocus(edit1_);
-      } else if (ui_ == LIST_PEERS) {
-        SetFocus(listbox_);
-      }
-      return true;
-
-    case WM_SIZE:
-      if (ui_ == CONNECT_TO_SERVER) {
-        LayoutConnectUI(true);
-      } else if (ui_ == LIST_PEERS) {
-        LayoutPeerListUI(true);
-      }
-      break;
-
-    case WM_CTLCOLORSTATIC:
-      *result = reinterpret_cast<LRESULT>(GetSysColorBrush(COLOR_WINDOW));
-      return true;
-
-    case WM_COMMAND:
-      if (button_ == reinterpret_cast<HWND>(lp)) {
-        if (BN_CLICKED == HIWORD(wp))
-          OnDefaultAction();
-      } else if (listbox_ == reinterpret_cast<HWND>(lp)) {
-        if (LBN_DBLCLK == HIWORD(wp)) {
-          OnDefaultAction();
-        }
-      }
-      return true;
-
-    case WM_CLOSE:
-      if (callback_)
-        callback_->Close();
-      break;
-  }
-  return false;
-}
-
-// static
-LRESULT CALLBACK MainWnd::WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
-  MainWnd* me =
-      reinterpret_cast<MainWnd*>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
-  if (!me && WM_CREATE == msg) {
-    CREATESTRUCT* cs = reinterpret_cast<CREATESTRUCT*>(lp);
-    me = reinterpret_cast<MainWnd*>(cs->lpCreateParams);
-    me->wnd_ = hwnd;
-    ::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(me));
-  }
-
-  LRESULT result = 0;
-  if (me) {
-    void* prev_nested_msg = me->nested_msg_;
-    me->nested_msg_ = &msg;
-
-    bool handled = me->OnMessage(msg, wp, lp, &result);
-    if (WM_NCDESTROY == msg) {
-      me->destroyed_ = true;
-    } else if (!handled) {
-      result = ::DefWindowProc(hwnd, msg, wp, lp);
-    }
-
-    if (me->destroyed_ && prev_nested_msg == NULL) {
-      me->OnDestroyed();
-      me->wnd_ = NULL;
-      me->destroyed_ = false;
-    }
-
-    me->nested_msg_ = prev_nested_msg;
-  } else {
-    result = ::DefWindowProc(hwnd, msg, wp, lp);
-  }
-
-  return result;
-}
-
-// static
-bool MainWnd::RegisterWindowClass() {
-  if (wnd_class_)
-    return true;
-
-  WNDCLASSEX wcex = {sizeof(WNDCLASSEX)};
-  wcex.style = CS_DBLCLKS;
-  wcex.hInstance = GetModuleHandle(NULL);
-  wcex.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
-  wcex.hCursor = ::LoadCursor(NULL, IDC_ARROW);
-  wcex.lpfnWndProc = &WndProc;
-  wcex.lpszClassName = kClassName;
-  wnd_class_ = ::RegisterClassEx(&wcex);
-  RTC_DCHECK(wnd_class_ != 0);
-  return wnd_class_ != 0;
-}
-
-void MainWnd::CreateChildWindow(HWND* wnd,
-                                MainWnd::ChildWindowID id,
-                                const wchar_t* class_name,
-                                DWORD control_style,
-                                DWORD ex_style) {
-  if (::IsWindow(*wnd))
-    return;
-
-  // Child windows are invisible at first, and shown after being resized.
-  DWORD style = WS_CHILD | control_style;
-  *wnd = ::CreateWindowEx(ex_style, class_name, L"", style, 100, 100, 100, 100,
-                          wnd_, reinterpret_cast<HMENU>(id),
-                          GetModuleHandle(NULL), NULL);
-  RTC_DCHECK(::IsWindow(*wnd) != FALSE);
-  ::SendMessage(*wnd, WM_SETFONT, reinterpret_cast<WPARAM>(GetDefaultFont()),
-                TRUE);
-}
-
-void MainWnd::CreateChildWindows() {
-  // Create the child windows in tab order.
-  CreateChildWindow(&label1_, LABEL1_ID, L"Static", ES_CENTER | ES_READONLY, 0);
-  CreateChildWindow(&edit1_, EDIT_ID, L"Edit",
-                    ES_LEFT | ES_NOHIDESEL | WS_TABSTOP, WS_EX_CLIENTEDGE);
-  CreateChildWindow(&label2_, LABEL2_ID, L"Static", ES_CENTER | ES_READONLY, 0);
-  CreateChildWindow(&edit2_, EDIT_ID, L"Edit",
-                    ES_LEFT | ES_NOHIDESEL | WS_TABSTOP, WS_EX_CLIENTEDGE);
-  CreateChildWindow(&button_, BUTTON_ID, L"Button", BS_CENTER | WS_TABSTOP, 0);
-
-  CreateChildWindow(&listbox_, LISTBOX_ID, L"ListBox",
-                    LBS_HASSTRINGS | LBS_NOTIFY, WS_EX_CLIENTEDGE);
-
-  ::SetWindowTextA(edit1_, server_.c_str());
-  ::SetWindowTextA(edit2_, port_.c_str());
-}
-
-void MainWnd::LayoutConnectUI(bool show) {
-  struct Windows {
-    HWND wnd;
-    const wchar_t* text;
-    size_t width;
-    size_t height;
-  } windows[] = {
-      {label1_, L"Server"},  {edit1_, L"XXXyyyYYYgggXXXyyyYYYggg"},
-      {label2_, L":"},       {edit2_, L"XyXyX"},
-      {button_, L"Connect"},
-  };
-
-  if (show) {
-    const size_t kSeparator = 5;
-    size_t total_width = (ARRAYSIZE(windows) - 1) * kSeparator;
-
-    for (size_t i = 0; i < ARRAYSIZE(windows); ++i) {
-      CalculateWindowSizeForText(windows[i].wnd, windows[i].text,
-                                 &windows[i].width, &windows[i].height);
-      total_width += windows[i].width;
-    }
-
-    RECT rc;
-    ::GetClientRect(wnd_, &rc);
-    size_t x = (rc.right / 2) - (total_width / 2);
-    size_t y = rc.bottom / 2;
-    for (size_t i = 0; i < ARRAYSIZE(windows); ++i) {
-      size_t top = y - (windows[i].height / 2);
-      ::MoveWindow(windows[i].wnd, static_cast<int>(x), static_cast<int>(top),
-                   static_cast<int>(windows[i].width),
-                   static_cast<int>(windows[i].height), TRUE);
-      x += kSeparator + windows[i].width;
-      if (windows[i].text[0] != 'X')
-        ::SetWindowText(windows[i].wnd, windows[i].text);
-      ::ShowWindow(windows[i].wnd, SW_SHOWNA);
-    }
-  } else {
-    for (size_t i = 0; i < ARRAYSIZE(windows); ++i) {
-      ::ShowWindow(windows[i].wnd, SW_HIDE);
-    }
-  }
-}
-
-void MainWnd::LayoutPeerListUI(bool show) {
-  if (show) {
-    RECT rc;
-    ::GetClientRect(wnd_, &rc);
-    ::MoveWindow(listbox_, 0, 0, rc.right, rc.bottom, TRUE);
-    ::ShowWindow(listbox_, SW_SHOWNA);
-  } else {
-    ::ShowWindow(listbox_, SW_HIDE);
-    InvalidateRect(wnd_, NULL, TRUE);
-  }
-}
-
-void MainWnd::HandleTabbing() {
-  bool shift = ((::GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0);
-  UINT next_cmd = shift ? GW_HWNDPREV : GW_HWNDNEXT;
-  UINT loop_around_cmd = shift ? GW_HWNDLAST : GW_HWNDFIRST;
-  HWND focus = GetFocus(), next;
-  do {
-    next = ::GetWindow(focus, next_cmd);
-    if (IsWindowVisible(next) &&
-        (GetWindowLong(next, GWL_STYLE) & WS_TABSTOP)) {
-      break;
-    }
-
-    if (!next) {
-      next = ::GetWindow(focus, loop_around_cmd);
-      if (IsWindowVisible(next) &&
-          (GetWindowLong(next, GWL_STYLE) & WS_TABSTOP)) {
-        break;
-      }
-    }
-    focus = next;
-  } while (true);
-  ::SetFocus(next);
-}
-
-//
-// MainWnd::VideoRenderer
-//
-
-MainWnd::VideoRenderer::VideoRenderer(
-    HWND wnd,
-    int width,
-    int height,
-    webrtc::VideoTrackInterface* track_to_render)
-    : wnd_(wnd), rendered_track_(track_to_render) {
-  ::InitializeCriticalSection(&buffer_lock_);
-  ZeroMemory(&bmi_, sizeof(bmi_));
-  bmi_.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-  bmi_.bmiHeader.biPlanes = 1;
-  bmi_.bmiHeader.biBitCount = 32;
-  bmi_.bmiHeader.biCompression = BI_RGB;
-  bmi_.bmiHeader.biWidth = width;
-  bmi_.bmiHeader.biHeight = -height;
-  bmi_.bmiHeader.biSizeImage =
-      width * height * (bmi_.bmiHeader.biBitCount >> 3);
-  rendered_track_->AddOrUpdateSink(this, rtc::VideoSinkWants());
-}
-
-MainWnd::VideoRenderer::~VideoRenderer() {
-  rendered_track_->RemoveSink(this);
-  ::DeleteCriticalSection(&buffer_lock_);
-}
-
-void MainWnd::VideoRenderer::SetSize(int width, int height) {
-  AutoLock<VideoRenderer> lock(this);
-
-  if (width == bmi_.bmiHeader.biWidth && height == bmi_.bmiHeader.biHeight) {
-    return;
-  }
-
-  bmi_.bmiHeader.biWidth = width;
-  bmi_.bmiHeader.biHeight = -height;
-  bmi_.bmiHeader.biSizeImage =
-      width * height * (bmi_.bmiHeader.biBitCount >> 3);
-  image_.reset(new uint8_t[bmi_.bmiHeader.biSizeImage]);
-}
-
-void MainWnd::VideoRenderer::OnFrame(const webrtc::VideoFrame& video_frame) {
-  {
-    AutoLock<VideoRenderer> lock(this);
-
-    rtc::scoped_refptr<webrtc::I420BufferInterface> buffer(
-        video_frame.video_frame_buffer()->ToI420());
-    if (video_frame.rotation() != webrtc::kVideoRotation_0) {
-      buffer = webrtc::I420Buffer::Rotate(*buffer, video_frame.rotation());
-    }
-
-    SetSize(buffer->width(), buffer->height());
-
-    RTC_DCHECK(image_.get() != NULL);
-    libyuv::I420ToARGB(buffer->DataY(), buffer->StrideY(), buffer->DataU(),
-                       buffer->StrideU(), buffer->DataV(), buffer->StrideV(),
-                       image_.get(),
-                       bmi_.bmiHeader.biWidth * bmi_.bmiHeader.biBitCount / 8,
-                       buffer->width(), buffer->height());
-  }
-  InvalidateRect(wnd_, NULL, TRUE);
-}
diff --git a/examples/peerconnection/client/peer_connection_client.cc b/examples/peerconnection/client/peer_connection_client.cc
index f173e42..01be678 100644
--- a/examples/peerconnection/client/peer_connection_client.cc
+++ b/examples/peerconnection/client/peer_connection_client.cc
@@ -19,6 +19,16 @@
 #include "rtc_base/win32socketserver.h"
 #endif
 
+#define PRINT_ENABLE
+
+#ifdef PRINT_ENABLE
+#define PRINT(x) printf("%s \n",#x);
+#endif
+
+#ifndef PRINT_ENABLE
+#define PRINT(x)
+#endif
+
 namespace {
 
 // This is our magical hangup signal.
@@ -27,11 +37,14 @@ const char kByeMessage[] = "BYE";
 const int kReconnectDelay = 2000;
 
 rtc::AsyncSocket* CreateClientSocket(int family) {
+
+  PRINT("Inside CreateClientSocket()..");
 #ifdef WIN32
   rtc::Win32Socket* sock = new rtc::Win32Socket();
   sock->CreateT(family, SOCK_STREAM);
   return sock;
 #elif defined(WEBRTC_POSIX)
+  PRINT ("Calling  rtc::Thread::Current()");
   rtc::Thread* thread = rtc::Thread::Current();
   RTC_DCHECK(thread != NULL);
   return thread->socketserver()->CreateAsyncSocket(family, SOCK_STREAM);
@@ -48,6 +61,7 @@ PeerConnectionClient::PeerConnectionClient()
 PeerConnectionClient::~PeerConnectionClient() {}
 
 void PeerConnectionClient::InitSocketSignals() {
+  PRINT("In PeerConnectionClient::InitSocketSignals...");
   RTC_DCHECK(control_socket_.get() != NULL);
   RTC_DCHECK(hanging_get_.get() != NULL);
   control_socket_->SignalCloseEvent.connect(this,
@@ -60,6 +74,8 @@ void PeerConnectionClient::InitSocketSignals() {
   control_socket_->SignalReadEvent.connect(this, &PeerConnectionClient::OnRead);
   hanging_get_->SignalReadEvent.connect(
       this, &PeerConnectionClient::OnHangingGetRead);
+  PRINT("Registered Socket Signal Callbacks");
+  PRINT("In PeerConnectionClient::InitSocketSignals...");
 }
 
 int PeerConnectionClient::id() const {
@@ -67,6 +83,8 @@ int PeerConnectionClient::id() const {
 }
 
 bool PeerConnectionClient::is_connected() const {
+  PRINT("myid");
+  PRINT(my_id_);
   return my_id_ != -1;
 }
 
@@ -76,6 +94,7 @@ const Peers& PeerConnectionClient::peers() const {
 
 void PeerConnectionClient::RegisterObserver(
     PeerConnectionClientObserver* callback) {
+  PRINT("Registering PeerConnectionClient::RegisterObserver()");
   RTC_DCHECK(!callback_);
   callback_ = callback;
 }
@@ -83,6 +102,12 @@ void PeerConnectionClient::RegisterObserver(
 void PeerConnectionClient::Connect(const std::string& server,
                                    int port,
                                    const std::string& client_name) {
+PRINT("In PeerConnectionClient::Connect()..");
+PRINT("/nSERVER:");
+PRINT(server.c_str());
+PRINT("/nclient:");
+PRINT(client_name.c_str());
+
   RTC_DCHECK(!server.empty());
   RTC_DCHECK(!client_name.empty());
 
@@ -106,17 +131,24 @@ void PeerConnectionClient::Connect(const std::string& server,
   client_name_ = client_name;
 
   if (server_address_.IsUnresolvedIP()) {
+
+    PRINT("UnresolvedIP : Server");
     state_ = RESOLVING;
     resolver_ = new rtc::AsyncResolver();
     resolver_->SignalDone.connect(this, &PeerConnectionClient::OnResolveResult);
     resolver_->Start(server_address_);
   } else {
+    PRINT("Calling DoConnect()");
+
     DoConnect();
   }
+PRINT("OUt PeerConnectionClient::Connect()");
 }
 
 void PeerConnectionClient::OnResolveResult(
     rtc::AsyncResolverInterface* resolver) {
+PRINT("In PeerConnectionClient::OnResolveResult()");
+
   if (resolver_->GetError() != 0) {
     callback_->OnServerConnectionFailure();
     resolver_->Destroy(false);
@@ -126,26 +158,36 @@ void PeerConnectionClient::OnResolveResult(
     server_address_ = resolver_->address();
     DoConnect();
   }
+PRINT("OUt PeerConnectionClient::OnResolveResult()");
 }
 
 void PeerConnectionClient::DoConnect() {
+
+  PRINT("Inside PeerConnectionClient::DoConnect()");
   control_socket_.reset(CreateClientSocket(server_address_.ipaddr().family()));
+  PRINT(" hanging_get_.reset(CreateClientSocket(server_address_.ipaddr().family())");
   hanging_get_.reset(CreateClientSocket(server_address_.ipaddr().family()));
   InitSocketSignals();
   char buffer[1024];
   snprintf(buffer, sizeof(buffer), "GET /sign_in?%s HTTP/1.0\r\n\r\n",
            client_name_.c_str());
   onconnect_data_ = buffer;
+  PRINT("GET /sign_in?%s HTTP/1.0\r\n\r\n");
+  PRINT(client_name_.c_str());
 
   bool ret = ConnectControlSocket();
-  if (ret)
+  if (ret) {
+    PRINT("DoConnect: ConnectControlSocket returned true");
     state_ = SIGNING_IN;
+  }
   if (!ret) {
     callback_->OnServerConnectionFailure();
   }
+PRINT("Out PeerConnectionClient::DoConnect()");
 }
 
 bool PeerConnectionClient::SendToPeer(int peer_id, const std::string& message) {
+PRINT("In PeerConnectionClient::SendToPeer()");
   if (state_ != CONNECTED)
     return false;
 
@@ -163,19 +205,23 @@ bool PeerConnectionClient::SendToPeer(int peer_id, const std::string& message) {
            my_id_, peer_id, message.length());
   onconnect_data_ = headers;
   onconnect_data_ += message;
+ PRINT("Out PeerConnectionClient::SendToPeer");
   return ConnectControlSocket();
 }
 
 bool PeerConnectionClient::SendHangUp(int peer_id) {
+PRINT("PeerConnectionClient::SendHangUp()");
   return SendToPeer(peer_id, kByeMessage);
 }
 
 bool PeerConnectionClient::IsSendingMessage() {
+PRINT("PeerConnectionClient::IsSendingMessage()");
   return state_ == CONNECTED &&
          control_socket_->GetState() != rtc::Socket::CS_CLOSED;
 }
 
 bool PeerConnectionClient::SignOut() {
+PRINT("In PeerConnectionClient::SignOut()");
   if (state_ == NOT_CONNECTED || state_ == SIGNING_OUT)
     return true;
 
@@ -190,6 +236,7 @@ bool PeerConnectionClient::SignOut() {
       snprintf(buffer, sizeof(buffer),
                "GET /sign_out?peer_id=%i HTTP/1.0\r\n\r\n", my_id_);
       onconnect_data_ = buffer;
+      PRINT("GET /sign_out?peer_id=%i HTTP/1.0\r\n\r\n");
       return ConnectControlSocket();
     } else {
       // Can occur if the app is closed before we finish connecting.
@@ -198,11 +245,14 @@ bool PeerConnectionClient::SignOut() {
   } else {
     state_ = SIGNING_OUT_WAITING;
   }
+PRINT("Out PeerConnectionClient::SignOut()");
+
 
   return true;
 }
 
 void PeerConnectionClient::Close() {
+PRINT("In PeerConnectionClient::Close()");
   control_socket_->Close();
   hanging_get_->Close();
   onconnect_data_.clear();
@@ -213,48 +263,71 @@ void PeerConnectionClient::Close() {
   }
   my_id_ = -1;
   state_ = NOT_CONNECTED;
+PRINT("Out PeerConnectionClient::Close()");
 }
 
 bool PeerConnectionClient::ConnectControlSocket() {
+PRINT("In PeerConnectionClient::ConnectControlSocket() ...");
   RTC_DCHECK(control_socket_->GetState() == rtc::Socket::CS_CLOSED);
   int err = control_socket_->Connect(server_address_);
+//PRINT("SERVRRADDS:%s",(char *)server_address_);
+
   if (err == SOCKET_ERROR) {
+   PRINT("PeerConnectionClient::ConnectControlSocket(): Connect failed");
     Close();
     return false;
   }
+PRINT("Out PeerConnectionClient::ConnectControlSocket() ");
+
   return true;
 }
 
 void PeerConnectionClient::OnConnect(rtc::AsyncSocket* socket) {
+  PRINT("Inside PeerConnectionClient::OnConnect()");
   RTC_DCHECK(!onconnect_data_.empty());
+  PRINT("On Control socket Sending data ::::");
+  PRINT(onconnect_data_.c_str());
+
   size_t sent = socket->Send(onconnect_data_.c_str(), onconnect_data_.length());
   RTC_DCHECK(sent == onconnect_data_.length());
   onconnect_data_.clear();
+PRINT("Out  PeerConnectionClient::OnConnect()");
+
 }
 
 void PeerConnectionClient::OnHangingGetConnect(rtc::AsyncSocket* socket) {
+PRINT("In PeerConnectionClient::OnHangingGetConnect()...");
   char buffer[1024];
   snprintf(buffer, sizeof(buffer), "GET /wait?peer_id=%i HTTP/1.0\r\n\r\n",
            my_id_);
   int len = static_cast<int>(strlen(buffer));
   int sent = socket->Send(buffer, len);
+PRINT("/nOnHangingGetConnect sent buff");
+PRINT(buffer);
   RTC_DCHECK(sent == len);
+PRINT("Out PeerConnectionClient::OnHangingGetConnect()...");
 }
 
 void PeerConnectionClient::OnMessageFromPeer(int peer_id,
                                              const std::string& message) {
+PRINT("In PeerConnectionClient::OnMessageFromPeer()...:::");
+PRINT(message.c_str());
   if (message.length() == (sizeof(kByeMessage) - 1) &&
       message.compare(kByeMessage) == 0) {
     callback_->OnPeerDisconnected(peer_id);
   } else {
     callback_->OnMessageFromPeer(peer_id, message);
   }
+PRINT("Out PeerConnectionClient::OnMessageFromPeer()...");
+
 }
 
 bool PeerConnectionClient::GetHeaderValue(const std::string& data,
                                           size_t eoh,
                                           const char* header_pattern,
                                           size_t* value) {
+PRINT("In PeerConnectionClient::GetHeaderValue()...");
+
   RTC_DCHECK(value != NULL);
   size_t found = data.find(header_pattern);
   if (found != std::string::npos && found < eoh) {
@@ -268,6 +341,8 @@ bool PeerConnectionClient::GetHeaderValue(const std::string& data,
                                           size_t eoh,
                                           const char* header_pattern,
                                           std::string* value) {
+PRINT("In PeerConnectionClient::GetHeaderValue()...");
+
   RTC_DCHECK(value != NULL);
   size_t found = data.find(header_pattern);
   if (found != std::string::npos && found < eoh) {
@@ -284,6 +359,8 @@ bool PeerConnectionClient::GetHeaderValue(const std::string& data,
 bool PeerConnectionClient::ReadIntoBuffer(rtc::AsyncSocket* socket,
                                           std::string* data,
                                           size_t* content_length) {
+PRINT("In PeerConnectionClient::ReadIntoBuffer()...");
+
   char buffer[0xffff];
   do {
     int bytes = socket->Recv(buffer, sizeof(buffer), nullptr);
@@ -316,10 +393,12 @@ bool PeerConnectionClient::ReadIntoBuffer(rtc::AsyncSocket* socket,
       RTC_LOG(LS_ERROR) << "No content length field specified by the server.";
     }
   }
+PRINT("Out  PeerConnectionClient::ReadIntoBuffer()...");
   return ret;
 }
 
 void PeerConnectionClient::OnRead(rtc::AsyncSocket* socket) {
+  PRINT("In PeerConnectionClient::OnRead()");
   size_t content_length = 0;
   if (ReadIntoBuffer(socket, &control_data_, &content_length)) {
     size_t peer_id = 0, eoh = 0;
@@ -366,12 +445,15 @@ void PeerConnectionClient::OnRead(rtc::AsyncSocket* socket) {
     if (state_ == SIGNING_IN) {
       RTC_DCHECK(hanging_get_->GetState() == rtc::Socket::CS_CLOSED);
       state_ = CONNECTED;
+      PRINT("Connecting Hanging Socket::::::::::::::::::::::");
       hanging_get_->Connect(server_address_);
     }
   }
+PRINT("Out  PeerConnectionClient::OnRead()");
 }
 
 void PeerConnectionClient::OnHangingGetRead(rtc::AsyncSocket* socket) {
+PRINT("In PeerConnectionClient::OnHangingGetRead()...");
   RTC_LOG(INFO) << __FUNCTION__;
   size_t content_length = 0;
   if (ReadIntoBuffer(socket, &notification_data_, &content_length)) {
@@ -410,14 +492,22 @@ void PeerConnectionClient::OnHangingGetRead(rtc::AsyncSocket* socket) {
 
   if (hanging_get_->GetState() == rtc::Socket::CS_CLOSED &&
       state_ == CONNECTED) {
-    hanging_get_->Connect(server_address_);
+      PRINT("hanging_get_->Connect(server_address_)");
+int err = hanging_get_->Connect(server_address_);
+if (err == SOCKET_ERROR) {
+       PRINT("PeerConnectionClient::OnHangingGetRead: hanging Connect failed");
+}
+
   }
+
 }
 
 bool PeerConnectionClient::ParseEntry(const std::string& entry,
                                       std::string* name,
                                       int* id,
                                       bool* connected) {
+PRINT("In PeerConnectionClient::ParseEntry()...");
+
   RTC_DCHECK(name != NULL);
   RTC_DCHECK(id != NULL);
   RTC_DCHECK(connected != NULL);
@@ -433,14 +523,20 @@ bool PeerConnectionClient::ParseEntry(const std::string& entry,
       *connected = atoi(&entry[separator + 1]) ? true : false;
     }
   }
+   PRINT("Out PeerConnectionClient::ParseEntry()...");
+
   return !name->empty();
 }
 
 int PeerConnectionClient::GetResponseStatus(const std::string& response) {
+PRINT("In  PeerConnectionClient::GetResponseStatus()...");
+
   int status = -1;
   size_t pos = response.find(' ');
   if (pos != std::string::npos)
     status = atoi(&response[pos + 1]);
+PRINT("Out PeerConnectionClient::GetResponseStatus()...");
+
   return status;
 }
 
@@ -448,6 +544,8 @@ bool PeerConnectionClient::ParseServerResponse(const std::string& response,
                                                size_t content_length,
                                                size_t* peer_id,
                                                size_t* eoh) {
+PRINT("In PeerConnectionClient::ParseServerResponse()...");
+
   int status = GetResponseStatus(response.c_str());
   if (status != 200) {
     RTC_LOG(LS_ERROR) << "Received error from server";
@@ -466,11 +564,14 @@ bool PeerConnectionClient::ParseServerResponse(const std::string& response,
   // See comment in peer_channel.cc for why we use the Pragma header and
   // not e.g. "X-Peer-Id".
   GetHeaderValue(response, *eoh, "\r\nPragma: ", peer_id);
+PRINT("Out PeerConnectionClient::ParseServerResponse()...");
 
   return true;
 }
 
 void PeerConnectionClient::OnClose(rtc::AsyncSocket* socket, int err) {
+PRINT("In PeerConnectionClient::OnClose()...");
+
   RTC_LOG(INFO) << __FUNCTION__;
 
   socket->Close();
@@ -481,11 +582,19 @@ void PeerConnectionClient::OnClose(rtc::AsyncSocket* socket, int err) {
   if (err != ECONNREFUSED) {
 #endif
     if (socket == hanging_get_.get()) {
+     PRINT("OnClose()is called for hanging socket::::::::");
       if (state_ == CONNECTED) {
+         PRINT("hanging_get_ Closed and reconnected");
         hanging_get_->Close();
-        hanging_get_->Connect(server_address_);
+        int err = hanging_get_->Connect(server_address_);
+        if (err == SOCKET_ERROR) {
+          PRINT("PeerConnectionClient::OnClose: hanging Connect failed");
+        }
+        PRINT("ReturnValue of hanging_get_->Connect:");
+        PRINT(err);
       }
     } else {
+      PRINT("OnClose of Control socket:::::::::");
       callback_->OnMessageSent(err);
     }
   } else {
@@ -494,13 +603,18 @@ void PeerConnectionClient::OnClose(rtc::AsyncSocket* socket, int err) {
       rtc::Thread::Current()->PostDelayed(RTC_FROM_HERE, kReconnectDelay, this,
                                           0);
     } else {
+     PRINT("/n**********");
       Close();
       callback_->OnDisconnected();
     }
   }
+PRINT("Out PeerConnectionClient::OnClose()...");
+
 }
 
 void PeerConnectionClient::OnMessage(rtc::Message* msg) {
   // ignore msg; there is currently only one supported message ("retry")
+ PRINT("In PeerConnectionClient::OnMessage()...");
   DoConnect();
+ PRINT("Out PeerConnectionClient::OnMessage()...");
 }
